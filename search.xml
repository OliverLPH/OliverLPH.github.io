<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python Grammar - Regular Expression</title>
      <link href="/2019/01/30/Python%20Grammar4/"/>
      <url>/2019/01/30/Python%20Grammar4/</url>
      <content type="html"><![CDATA[<p>正则表达式是一个非常常用而且强大的模块，在各个语言中均有很广泛的用途。</p><p><img src="https://raw.githubusercontent.com/OliverLPH/Pictures/master/照片/Regex.png" alt="Regex sample"></p><p>用正则表达式可以模糊的匹配出所需要的内容。</p><a id="more"></a><h1 id="Python-Grammar-Regular-Expression"><a href="#Python-Grammar-Regular-Expression" class="headerlink" title="Python Grammar - Regular Expression"></a>Python Grammar - Regular Expression</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regex = &lt;正则表达式&gt;</span><br><span class="line">info = <span class="string">'&lt;&gt;'</span>(str)</span><br><span class="line">re.match(regex,info)</span><br></pre></td></tr></table></figure><p>语法比较简单，但是里面匹配的时候，有一些特殊符号的作用</p><p>()只负责提取括号内的内容<br>    group(0): 代表提取出最外层括号的内容<br>    group(1): 代表提取出第一个括号内的内容，然后数字叠加以此内推</p><h3 id="Anchor"><a href="#Anchor" class="headerlink" title="Anchor"></a>Anchor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^               # 限定开头字符Start of string, or start of line in multi-line pattern</span><br><span class="line">\A              # Start of string</span><br><span class="line">$               # 限定末尾字符End of string, or end of line in multi-line pattern</span><br><span class="line">\Z              # End of string</span><br><span class="line">\b              # Word boundary</span><br><span class="line">\B              # Not word boundary</span><br><span class="line">\&lt;              # Start of word</span><br><span class="line">\&gt;              # End of word</span><br></pre></td></tr></table></figure><h3 id="Quantifiers"><a href="#Quantifiers" class="headerlink" title="Quantifiers"></a>Quantifiers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*               # 0 or more</span><br><span class="line">+               # 1 or more</span><br><span class="line">?               # 0 or 1</span><br><span class="line">&#123;3&#125;             # Exactly 3</span><br><span class="line">&#123;3,&#125;            # 3 or more</span><br><span class="line">&#123;3,5&#125;           # 3, 4 or 5</span><br><span class="line">&#123;,5&#125;            # 5 or less</span><br></pre></td></tr></table></figure><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><h4 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\c              # Control character</span><br><span class="line">\s              # White space</span><br><span class="line">\S              # Not white space,表示不为空格都可以,但是只能表示一个字符</span><br><span class="line">\d              # Digit 表示数字</span><br><span class="line">\D              # Not digit</span><br><span class="line">\w              # Word,表示[0-9,a-z,A-Z,_这些字符] （数字，字符，下划线）</span><br><span class="line">\W              # Not word</span><br><span class="line">\x              # Hexade-cimal digit</span><br><span class="line">\O              # Octal digit</span><br></pre></td></tr></table></figure><h4 id="Special"><a href="#Special" class="headerlink" title="Special"></a>Special</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\n              # New line</span><br><span class="line">\r              # Carriage return</span><br><span class="line">\t              # Tab</span><br><span class="line">\v              # Vertical tab</span><br><span class="line">\f              # Form feed</span><br><span class="line">\xxx            # Octal character xxx</span><br><span class="line">\xhh            # Hex character hh</span><br></pre></td></tr></table></figure><h3 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.               # Any character except new line (\n)</span><br><span class="line">(a|b)           # a or b</span><br><span class="line">(...)           # Group</span><br><span class="line">(?:...)         # Passive (non-c-apt-uring) group</span><br><span class="line">[abc]           # Range (a or b or c)</span><br><span class="line">[^abc]          # Not a or b or c</span><br><span class="line">[a-q]           # Letter from a to q</span><br><span class="line">[A-Q]           # Upper case letter from A to Q</span><br><span class="line">[0-7]           # Digit from 0 to 7</span><br><span class="line">\n              # nth group/-sub-pattern</span><br><span class="line">[\u4E00-\u9FA5] # 汉字区间，表示所有的汉字，均可以匹配出来</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python Grammar - data structures</title>
      <link href="/2019/01/30/Python%20Grammar3/"/>
      <url>/2019/01/30/Python%20Grammar3/</url>
      <content type="html"><![CDATA[<p>Python的数据结构语法总结和小抄<br><a id="more"></a></p><h1 id="Python-Grammar-Data-Structures"><a href="#Python-Grammar-Data-Structures" class="headerlink" title="Python Grammar - Data Structures"></a>Python Grammar - Data Structures</h1><h2 id="Python数据结构"><a href="#Python数据结构" class="headerlink" title="Python数据结构"></a>Python数据结构</h2><h3 id="堆-ADT"><a href="#堆-ADT" class="headerlink" title="堆 ADT"></a>堆 ADT</h3><p>python的堆，可以用内置库实现priority queue algorithm优先级队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment">#内置堆默认为小根堆</span></span><br><span class="line"><span class="comment">#初始化堆</span></span><br><span class="line">PriorityQueue = [] <span class="comment">#用列表来做储存的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#增，往堆里添加item</span></span><br><span class="line"><span class="comment">#heapq.heappush(heap, item)</span></span><br><span class="line">heapq.heappush(PriorityQueue,<span class="number">6</span>)</span><br><span class="line">heapq.heappush(PriorityQueue,<span class="number">1</span>)</span><br><span class="line">heapq.heappush(PriorityQueue,<span class="number">3</span>)</span><br><span class="line">heapq.heappush(PriorityQueue,<span class="number">4</span>)</span><br><span class="line">heapq.heappush(PriorityQueue,<span class="number">5</span>)</span><br><span class="line">print(PriorityQueue)</span><br><span class="line"><span class="comment">#以上的代码往堆里压入了6，1，3，4，5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#弹出堆里的最小值</span></span><br><span class="line"><span class="comment">#heapq.heappop(heap)</span></span><br><span class="line">min_heap = heapq.heappop(PriorityQueue)</span><br><span class="line">print(min_heap)</span><br><span class="line">print(PriorityQueue)</span><br><span class="line"><span class="comment">#push和pop两个操作一起进行,push item进去，pop最小值出来</span></span><br><span class="line"><span class="comment">#heapq.heappushpop(heap, item)</span></span><br><span class="line"><span class="comment">#该操作效率相比于 分别进行 push &amp; pop更高</span></span><br><span class="line">min_heap2 = heapq.heappushpop(PriorityQueue, <span class="number">100</span>)</span><br><span class="line">print(min_heap2)</span><br><span class="line">print(PriorityQueue)</span><br></pre></td></tr></table></figure><p>堆排序也可以基于内置的heapq库来进行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(iterable)</span>:</span></span><br><span class="line">h = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line">heapq.heappush(h, value)</span><br><span class="line"><span class="keyword">return</span> [heapq.heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h))]</span><br><span class="line"></span><br><span class="line">list_ = [<span class="number">100</span>,<span class="number">200</span>,<span class="number">50</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">666</span>,<span class="number">333</span>]</span><br><span class="line">print(heapsort(list_))</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python Grammar - functions</title>
      <link href="/2019/01/30/Python%20Grammar2/"/>
      <url>/2019/01/30/Python%20Grammar2/</url>
      <content type="html"><![CDATA[<p>Python的函数式编程语法总结和小抄<br><a id="more"></a></p><h1 id="Python-Grammar-Functions"><a href="#Python-Grammar-Functions" class="headerlink" title="Python Grammar - Functions"></a>Python Grammar - Functions</h1><h2 id="Python的函数式编程"><a href="#Python的函数式编程" class="headerlink" title="Python的函数式编程"></a>Python的函数式编程</h2><h3 id="函数式编程的特性"><a href="#函数式编程的特性" class="headerlink" title="函数式编程的特性"></a>函数式编程的特性</h3><ol><li><p>对象，Mutable和Immutable对象<br>Muatble对象:  list, dict, set<br>Immutable对象: strings, tuples, numbers</p><p>1.1. 区分Muatble对象和Immutable对象</p><p>区别mutable对象和immutable对象的方法很简单，只要看该对象的位置是否发生改变。<br>查找对象位置id().<br>比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = <span class="number">1</span></span><br><span class="line">In [<span class="number">2</span>]: id(a)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">4345522256</span></span><br><span class="line">In [<span class="number">3</span>]: a = <span class="number">2</span></span><br><span class="line">In [<span class="number">4</span>]: id(a)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">4345522288</span></span><br><span class="line">In [<span class="number">5</span>]: id(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">4345522288</span></span><br></pre></td></tr></table></figure><p>从这段代码可以看出来，当a=2的时候，id(a)的地址是id(2)的地址，因此a自己是没有创建地址的，只是被指向了2的地址。</p><blockquote><p>immutable 并不是绝对的不可变。</p><blockquote><p>比如若是tuple里面包含的是一个mutable object，那么mutable object的值仍然是可变的。但是因为tuple 中的 mutable object 改变的只是 value而不是identity。因此tuple仍然是immutable的object。</p></blockquote></blockquote><p>1.2 immutable data的作用</p><p>像Clojure一样，默认上变量是不可变的，如果你要改变变量，你需要把变量copy出去修改。这样一来，可以让你的程序少很多Bug。因为，程序中的状态不好维护，在并发的时候更不好维护。（你可以试想一下如果你的程序有个复杂的状态，当以后别人改你代码的时候，是很容易出bug的，在并行中这样的问题就更多了）</p></li><li><p>first class functions<br>可以理解为面向对象编程</p></li><li><p>尾递归优化<br>Python不支持尾递归优化</p></li></ol><h3 id="函数式编程的方法"><a href="#函数式编程的方法" class="headerlink" title="函数式编程的方法"></a>函数式编程的方法</h3><ol><li>经典函数: Map &amp; Reduce</li></ol><p>在Python中，Map reduce用的非常之多</p><p>举几个简单的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; length = map(len,[&quot;123&quot;,&quot;425&quot;,&quot;abc&quot;])</span><br><span class="line">&gt;&gt; print(list(length))</span><br><span class="line">&gt;&gt; [3, 3, 3] #输出</span><br></pre></td></tr></table></figure><p>Map函数还可以和lambda函数一起使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; square_list = map(<span class="keyword">lambda</span> x:x*x, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>])</span><br><span class="line">&gt;&gt; print(list(square_list))</span><br><span class="line">&gt;&gt; [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">100</span>] <span class="comment">#输出</span></span><br></pre></td></tr></table></figure><p>Map函数用来批量开根号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; square_root_list = map(<span class="keyword">lambda</span> x:pow(x,<span class="number">0.5</span>), [<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">&gt;&gt; print(list(square_root_list))</span><br><span class="line">&gt;&gt; [<span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">1.4142135623730951</span>, <span class="number">1.7320508075688772</span>] <span class="comment">#输出</span></span><br></pre></td></tr></table></figure><p>然后就是reduce函数怎么用</p><p>在Python3中，reduce() 函数已经被从全局名字空间里移除了，它现在被放置在 fucntools 模块里，如果想要使用它，则需要通过引入functools模块来调用 reduce()函数：</p><p>举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="comment">#必须要先从functool里面调用才可以用</span></span><br><span class="line">&gt;&gt; <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">&gt;&gt; factorial = reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">&gt;&gt; print(factorial)</span><br><span class="line">&gt;&gt; <span class="number">15</span> <span class="comment">#输出</span></span><br></pre></td></tr></table></figure><p>这个例子相当于是计算了((1+2)+3)+4)+5),就是叠加了起来。其中 reduce(function, iterable[, initializer]), fucntion函数必须要有两个入参，每次先从第一二个参数开始运算function，然后得出了结论，就可以和第三个参数继续运算。因此符合了Reduce的思想，将运算分割开来了。</p><p>因为reduce的特性，阶乘，叠加，求和等思路的的可以用用reduce。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">&gt;&gt; itera = reduce(<span class="keyword">lambda</span> x,y: x*y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">&gt;&gt; print(itera)</span><br><span class="line">&gt;&gt; <span class="number">720</span> <span class="comment">#输出</span></span><br></pre></td></tr></table></figure><p>上面的代码就是输出了6的阶乘</p><p>参考网页: <a href="https://coolshell.cn/articles/10822.html" target="_blank" rel="noopener">函数式编程</a><br>这个例子是从该网页看到的</p><p>还有一些别函数filter, find, all, any(其它函数式的语言也有),可以让你的代码更简洁,更清楚。</p><p>计算数组中正数的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">num =[<span class="number">2</span>, <span class="number">-5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">-2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-3</span>, <span class="number">8</span>]</span><br><span class="line">positive_num_cnt = <span class="number">0</span></span><br><span class="line">positive_num_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</span><br><span class="line">    <span class="keyword">if</span> num[i] &gt; <span class="number">0</span>:</span><br><span class="line">        positive_num_cnt += <span class="number">1</span></span><br><span class="line">        positive_num_sum += num[i]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> positive_num_cnt &gt; <span class="number">0</span>:</span><br><span class="line">    average = positive_num_sum / positive_num_cnt</span><br><span class="line"> </span><br><span class="line">print(average) <span class="comment">#输出5</span></span><br></pre></td></tr></table></figure><p>如果采用函数式编程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">positive_num = filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span>, num)</span><br><span class="line">average = reduce(<span class="keyword">lambda</span> x,y: x+y, positive_num) / len( positive_num )</span><br></pre></td></tr></table></figure><p>如上面的代码所示，两句话就把这个问题解决了</p><ol start="2"><li><p>Pipeline </p></li><li><p>Recursing </p></li><li><p>currying</p></li><li><p>higher order function  </p></li></ol><h3 id="函数式编程的好处"><a href="#函数式编程的好处" class="headerlink" title="函数式编程的好处"></a>函数式编程的好处</h3><ol><li>parallelization 并行</li><li>lazy evaluation 惰性求值</li><li>determinism 确定性</li></ol>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python Grammar - Basic</title>
      <link href="/2019/01/30/Python%20Grammar1/"/>
      <url>/2019/01/30/Python%20Grammar1/</url>
      <content type="html"><![CDATA[<p>Python基础语法总结和小抄<br><a id="more"></a></p><h1 id="Python-Grammar-Basic"><a href="#Python-Grammar-Basic" class="headerlink" title="Python Grammar - Basic"></a>Python Grammar - Basic</h1><h2 id="Python基本语法"><a href="#Python基本语法" class="headerlink" title="Python基本语法"></a>Python基本语法</h2><h3 id="数据格式-Data-Types"><a href="#数据格式-Data-Types" class="headerlink" title="数据格式 Data Types"></a>数据格式 Data Types</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>           <span class="comment"># 整数(integer)</span></span><br><span class="line">b = <span class="number">2.0</span>         <span class="comment"># 浮点数(float)</span></span><br><span class="line">c = <span class="number">3.3e6</span>       <span class="comment"># 指数(exponential)</span></span><br><span class="line">d = <span class="number">1.9</span> + <span class="number">0.5j</span>  <span class="comment"># 复数(complex)</span></span><br><span class="line">e = <span class="number">3</span> &gt; <span class="number">5</span>       <span class="comment"># 布尔(boolean)</span></span><br><span class="line">f = <span class="string">'test'</span>      <span class="comment"># 字符串(string)</span></span><br></pre></td></tr></table></figure><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]          <span class="comment"># manually initialization</span></span><br><span class="line">b = list(range(<span class="number">5</span>))                   <span class="comment"># initialize from iteratable</span></span><br><span class="line">c = [num**<span class="number">2</span> <span class="keyword">for</span> num <span class="keyword">in</span> b]             <span class="comment"># list comprehension</span></span><br><span class="line">d = [num**<span class="number">2</span> <span class="keyword">for</span> num <span class="keyword">in</span> b <span class="keyword">if</span> num &lt; <span class="number">3</span>]  <span class="comment"># conditioned list comprehension</span></span><br><span class="line">e = c[<span class="number">0</span>]                              <span class="comment"># access element</span></span><br><span class="line">f = c[<span class="number">1</span>:<span class="number">2</span>]                           <span class="comment"># access a slice of the list</span></span><br><span class="line">g = c[<span class="number">-1</span>]                             <span class="comment"># access last element</span></span><br><span class="line">h = [<span class="string">'re'</span>, <span class="string">'bl'</span>] + [<span class="string">'gr'</span>]             <span class="comment"># list concatenation</span></span><br><span class="line">i = [<span class="string">'re'</span>] * <span class="number">5</span>                        <span class="comment"># repeat a list</span></span><br><span class="line">[<span class="string">'re'</span>, <span class="string">'bl'</span>].index(<span class="string">'re'</span>)              <span class="comment"># returns index of 're'</span></span><br><span class="line">a.append(<span class="string">'yellow'</span>)                    <span class="comment"># add new element to end of list</span></span><br><span class="line">a.extend(b)                           <span class="comment"># add elements from list `b` to end of list `a`</span></span><br><span class="line">a.insert(<span class="number">1</span>, <span class="string">'yellow'</span>)                 <span class="comment"># insert element in specified position</span></span><br><span class="line"><span class="string">'re'</span> <span class="keyword">in</span> [<span class="string">'re'</span>, <span class="string">'bl'</span>]                  <span class="comment"># true if 're' in list</span></span><br><span class="line"><span class="string">'fi'</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'re'</span>, <span class="string">'bl'</span>]              <span class="comment"># true if 'fi' not in list</span></span><br><span class="line">sorted([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])                     <span class="comment"># returns sorted list</span></span><br><span class="line">a.pop(<span class="number">2</span>)                              <span class="comment"># remove and return item at index (default last)</span></span><br></pre></td></tr></table></figure><h3 id="字典-Dictionaries"><a href="#字典-Dictionaries" class="headerlink" title="字典 Dictionaries"></a>字典 Dictionaries</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'red'</span>: <span class="string">'rouge'</span>, <span class="string">'blue'</span>: <span class="string">'bleu'</span>&#125;         <span class="comment"># dictionary</span></span><br><span class="line">b = a[<span class="string">'red'</span>]                                 <span class="comment"># translate item</span></span><br><span class="line"><span class="string">'red'</span> <span class="keyword">in</span> a                                   <span class="comment"># true if dictionary a contains key 'red'</span></span><br><span class="line">c = [value <span class="keyword">for</span> key, value <span class="keyword">in</span> a.items()]      <span class="comment"># loop through contents</span></span><br><span class="line">d = a.get(<span class="string">'yellow'</span>, <span class="string">'no translation found'</span>)  <span class="comment"># return default</span></span><br><span class="line">a.setdefault(<span class="string">'extra'</span>, []).append(<span class="string">'cyan'</span>)     <span class="comment"># init key with default</span></span><br><span class="line">a.update(&#123;<span class="string">'green'</span>: <span class="string">'vert'</span>, <span class="string">'brown'</span>: <span class="string">'brun'</span>&#125;) <span class="comment"># update dictionary by data from another one</span></span><br><span class="line">a.keys()                                     <span class="comment"># get list of keys</span></span><br><span class="line">a.values()                                   <span class="comment"># get list of values</span></span><br><span class="line">a.items()                                    <span class="comment"># get list of key-value pairs</span></span><br><span class="line"><span class="keyword">del</span> a[<span class="string">'red'</span>]                                 <span class="comment"># delete key and associated with it value</span></span><br><span class="line">a.pop(<span class="string">'blue'</span>)                                <span class="comment"># remove specified key and return the corresponding value</span></span><br></pre></td></tr></table></figure><h3 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合 Sets"></a>集合 Sets</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;                                <span class="comment"># initialize manually</span></span><br><span class="line">b = set(range(<span class="number">5</span>))                            <span class="comment"># initialize from iteratable</span></span><br><span class="line">a.add(<span class="number">13</span>)                                    <span class="comment"># add new element to set</span></span><br><span class="line">a.discard(<span class="number">13</span>)                                <span class="comment"># discard element from set</span></span><br><span class="line">a.update([<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>])                       <span class="comment"># update set with elements from iterable</span></span><br><span class="line">a.pop()                                      <span class="comment"># remove and return an arbitrary set element</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;                               <span class="comment"># true if 2 in set</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;                           <span class="comment"># true if 5 not in set</span></span><br><span class="line">a.issubset(b)                                <span class="comment"># test whether every element in a is in b</span></span><br><span class="line">a &lt;= b                                       <span class="comment"># issubset in operator form</span></span><br><span class="line">a.issuperset(b)                              <span class="comment"># test whether every element in b is in a</span></span><br><span class="line">a &gt;= b                                       <span class="comment"># issuperset in operator form</span></span><br><span class="line">a.intersection(b)                            <span class="comment"># return the intersection of two sets as a new set</span></span><br><span class="line">a.difference(b)                              <span class="comment"># return the difference of two or more sets as a new set</span></span><br><span class="line">a - b                                        <span class="comment"># difference in operator form</span></span><br><span class="line">a.symmetric_difference(b)                    <span class="comment"># return the symmetric difference of two sets as a new set</span></span><br><span class="line">a.union(b)                                   <span class="comment"># return the union of sets as a new set</span></span><br><span class="line">c = frozenset()                              <span class="comment"># the same as set but immutable</span></span><br></pre></td></tr></table></figure><h3 id="字符串-Strings"><a href="#字符串-Strings" class="headerlink" title="字符串 Strings"></a>字符串 Strings</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'red'</span>                      <span class="comment"># assignment</span></span><br><span class="line">char = a[<span class="number">2</span>]                    <span class="comment"># access individual characters</span></span><br><span class="line"><span class="string">'red '</span> + <span class="string">'blue'</span>                <span class="comment"># string concatenation</span></span><br><span class="line"><span class="string">'1, 2, three'</span>.split(<span class="string">','</span>)       <span class="comment"># split string into list</span></span><br><span class="line"><span class="string">'.'</span>.join([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'three'</span>])  <span class="comment"># concatenate list into string</span></span><br></pre></td></tr></table></figure><h3 id="运算符号-Operators"><a href="#运算符号-Operators" class="headerlink" title="运算符号 Operators"></a>运算符号 Operators</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>             <span class="comment"># assignment</span></span><br><span class="line">a += <span class="number">1</span> (*=, /=)   <span class="comment"># change and assign</span></span><br><span class="line"><span class="number">3</span> + <span class="number">2</span>             <span class="comment"># addition</span></span><br><span class="line"><span class="number">3</span> / <span class="number">2</span>             <span class="comment"># integer (python2) or float (python3) division</span></span><br><span class="line"><span class="number">3</span> // <span class="number">2</span>            <span class="comment"># integer division</span></span><br><span class="line"><span class="number">3</span> * <span class="number">2</span>             <span class="comment"># multiplication</span></span><br><span class="line"><span class="number">3</span> ** <span class="number">2</span>            <span class="comment"># exponent</span></span><br><span class="line"><span class="number">3</span> % <span class="number">2</span>             <span class="comment"># remainder</span></span><br><span class="line">abs(a)            <span class="comment"># absolute value</span></span><br><span class="line"><span class="number">1</span> == <span class="number">1</span>            <span class="comment"># equal</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span>             <span class="comment"># larger</span></span><br><span class="line"><span class="number">2</span> &lt; <span class="number">1</span>             <span class="comment"># smaller</span></span><br><span class="line"><span class="number">1</span> != <span class="number">2</span>            <span class="comment"># not equal</span></span><br><span class="line"><span class="number">1</span> != <span class="number">2</span> <span class="keyword">and</span> <span class="number">2</span> &lt; <span class="number">3</span>  <span class="comment"># logical AND</span></span><br><span class="line"><span class="number">1</span> != <span class="number">2</span> <span class="keyword">or</span> <span class="number">2</span> &lt; <span class="number">3</span>   <span class="comment"># logical OR</span></span><br><span class="line"><span class="keyword">not</span> <span class="number">1</span> == <span class="number">2</span>        <span class="comment"># logical NOT</span></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> b          <span class="comment"># test if a is in b</span></span><br><span class="line">a <span class="keyword">is</span> b            <span class="comment"># test if objects point to the same memory (id)</span></span><br></pre></td></tr></table></figure><h3 id="循环-Control-Flow"><a href="#循环-Control-Flow" class="headerlink" title="循环 Control Flow"></a>循环 Control Flow</h3><h4 id="if-elif-else-循环"><a href="#if-elif-else-循环" class="headerlink" title="if/elif/else 循环"></a>if/elif/else 循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> a + b == <span class="number">3</span>:</span><br><span class="line">print(<span class="string">'True'</span>)</span><br><span class="line"><span class="keyword">elif</span> a + b == <span class="number">1</span>:</span><br><span class="line">print(<span class="string">'False'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'?'</span>)</span><br></pre></td></tr></table></figure><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for</span></span><br><span class="line">a = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> a:</span><br><span class="line">    print(color)</span><br></pre></td></tr></table></figure><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> number &lt; <span class="number">10</span>:</span><br><span class="line">    print(number)</span><br><span class="line">    number += <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(number)</span><br><span class="line">    number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> number &gt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h3 id="函数，类，生成器，装饰器-Functions-Classes-Generators-Decorators"><a href="#函数，类，生成器，装饰器-Functions-Classes-Generators-Decorators" class="headerlink" title="函数，类，生成器，装饰器 Functions, Classes, Generators, Decorators"></a>函数，类，生成器，装饰器 Functions, Classes, Generators, Decorators</h3><h4 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 Functions"></a>函数 Functions</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function groups code statements and possibly</span></span><br><span class="line"><span class="comment"># returns a derived value</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(a1, a2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line"></span><br><span class="line">x = myfunc(a1, a2)</span><br></pre></td></tr></table></figure><h4 id="函数-Lambda-Expression"><a href="#函数-Lambda-Expression" class="headerlink" title="函数 Lambda Expression"></a>函数 Lambda Expression</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># returns a derived value by Lambda Expression</span></span><br><span class="line">mylambda = <span class="keyword">lambda</span> a1 : a1 + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="类，对象-Classes"><a href="#类，对象-Classes" class="headerlink" title="类，对象 Classes"></a>类，对象 Classes</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Class groups attributes (data)</span></span><br><span class="line"><span class="comment"># and associated methods (functions)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.x)</span><br><span class="line"></span><br><span class="line">x = Point(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器 Generators"></a>生成器 Generators</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generator iterates without</span></span><br><span class="line"><span class="comment"># creating all values at once</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstn</span><span class="params">(n)</span>:</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x = [i <span class="keyword">for</span> i <span class="keyword">in</span> firstn(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><h4 id="装饰器-Decorators"><a href="#装饰器-Decorators" class="headerlink" title="装饰器 Decorators"></a>装饰器 Decorators</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Decorator can be used to modify</span></span><br><span class="line"><span class="comment"># the behaviour of a function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDecorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></span><br><span class="line">        self.f = f</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"call"</span>)</span><br><span class="line">        self.f()</span><br><span class="line"></span><br><span class="line"><span class="meta">@myDecorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_funct</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'func'</span>)</span><br><span class="line"></span><br><span class="line">my_funct()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown常用语法（一）</title>
      <link href="/2019/01/17/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/01/17/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Markdown 的相关常用命令<br><a id="more"></a></p><h1 id="Markdown-常用语法（一）"><a href="#Markdown-常用语法（一）" class="headerlink" title="Markdown 常用语法（一）"></a>Markdown 常用语法（一）</h1><h2 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h2><p>常用的 Markdown的插入命令</p><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">插入图片的名字</span>](<span class="link">https://raw.githubusercontent.com/OliverLPH/Pictures/master/照片/Skye的晚霞.JPG</span>)</span><br></pre></td></tr></table></figure><p>但是上面这个方式无法选择图片显示的位置，和选择图片的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img width = &quot;100&quot; height =&apos;90&apos; src=&quot;https://raw.githubusercontent.com/OliverLPH/Pictures/master/照片/Skye的晚霞.JPG&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这个代码可以修改图片的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align=center&gt;&lt;img width = &quot;100&quot; height =&apos;90&apos; src=&quot;https://raw.githubusercontent.com/OliverLPH/Pictures/master/照片/Skye的晚霞.JPG&quot;/&gt;&lt;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div align=left&gt;&lt;img width = &quot;100&quot; height =&apos;90&apos; src=&quot;https://raw.githubusercontent.com/OliverLPH/Pictures/master/照片/Skye的晚霞.JPG&quot;/&gt;&lt;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div align=right&gt;&lt;img width = &quot;100&quot; height =&apos;90&apos; src=&quot;https://raw.githubusercontent.com/OliverLPH/Pictures/master/照片/Skye的晚霞.JPG&quot;/&gt;&lt;div&gt;</span><br></pre></td></tr></table></figure><p>这个代码可以修改图片的位置。</p><p><div align="center"><img width="100" height="90" src="https://raw.githubusercontent.com/OliverLPH/Pictures/master/照片/Skye的晚霞.JPG"><div></div></div></p><h3 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src=&quot;https://www.bilibili.com/video/av2271112&quot; width=&quot;320&quot; height=&quot;180&quot;</span><br><span class="line"> controls=&quot;controls&quot;&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure><video src="https://www.bilibili.com/video/av2271112" width="320" height="180" controls="controls"></video><p>上面的代码可以插入视频，这个视频是雷总的著名歌曲。</p><h3 id="插入音乐"><a href="#插入音乐" class="headerlink" title="插入音乐"></a>插入音乐</h3><p>Markdown支持插入 在线音乐的外链，网易云音乐是可以的。</p><p>参考: <a href="https://www.oschina.net/question/866260_2247433?sort=default" target="_blank" rel="noopener">markdown插入网易云音乐</a></p><h3 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h3><p>Markdown插入公式的操作比较简单，将latex格式的公式放在”$”里面就可以了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$L<span class="emphasis">_\theta(x)=\prod^m_</span>&#123;i=1&#125;h<span class="emphasis">_\theta(x^i;\theta)^&#123;yi&#125; \cdot (1-h_</span>\theta(x^i;\theta))^&#123;1-y^i&#125;$$</span><br></pre></td></tr></table></figure><p>$$L_\theta(x)=\prod^m_{i=1}h_\theta(x^i;\theta)^{yi} \cdot (1-h_\theta(x^i;\theta))^{1-y^i}$$</p><h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><p>表格的插入操作也比较简单，但是Markdown貌似不支持合并单元格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| Student | Class | Age | Gender |</span><br><span class="line">| --- | --- | --- | --- |</span><br><span class="line">| Oliver | A | 19 | M |</span><br><span class="line">| Allie | A | 18 | F |</span><br><span class="line">| Lee | B | 20 | M |</span><br><span class="line">| Jerry | A | 19 | M |</span><br><span class="line">| Frank | B | 18 | F |</span><br></pre></td></tr></table></figure><table><thead><tr><th>Student</th><th>Class</th><th>Age</th><th>Gender</th></tr></thead><tbody><tr><td>Oliver</td><td>A</td><td>19</td><td>M</td></tr><tr><td>Allie</td><td>A</td><td>18</td><td>F</td></tr><tr><td>Lee</td><td>B</td><td>20</td><td>M</td></tr><tr><td>Jerry</td><td>A</td><td>19</td><td>M</td></tr><tr><td>Frank</td><td>B</td><td>18</td><td>F</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jupyter添加新kernel(Mac)</title>
      <link href="/2018/12/15/Jupyter%E6%B7%BB%E5%8A%A0%E6%96%B0kernel-Mac/"/>
      <url>/2018/12/15/Jupyter%E6%B7%BB%E5%8A%A0%E6%96%B0kernel-Mac/</url>
      <content type="html"><![CDATA[<p>在 Anaconda中创建了新的虚拟环境，但是在Jupyter Notebook或者Jupyter lab里却看不见，然后以下是解决办法。</p><a id="more"></a> <h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><p>首先打开 Terminal界面，创建新环境 “”new_env_”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda create -n new_env</span><br></pre></td></tr></table></figure><p>查询当前 conda包含的虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda env list</span><br></pre></td></tr></table></figure><p>变更当前环境至指定虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source activate new_env</span><br></pre></td></tr></table></figure><h2 id="将虚拟环境添加到Jupyter"><a href="#将虚拟环境添加到Jupyter" class="headerlink" title="将虚拟环境添加到Jupyter"></a>将虚拟环境添加到Jupyter</h2><p>在Terminal里首先需要切换到需要添加的环境中，然后输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m ipykernel install --name new_env</span><br></pre></td></tr></table></figure><ol><li><p>此时如果 提示缺失 ipykernel，则返回 conda进行安装。</p></li><li><p>如果 提示缺失权限，则 添加 sudo 然后输入密码则可以完成添加。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo python -m ipykernel install --name new_env</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 工具 </tag>
            
            <tag> Jupyter Notebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo常用命令（一）</title>
      <link href="/2018/12/15/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A41/"/>
      <url>/2018/12/15/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A41/</url>
      <content type="html"><![CDATA[<p>Hexo 的相关常用命令<br><a id="more"></a></p><h1 id="Hexo-常用命令（一）"><a href="#Hexo-常用命令（一）" class="headerlink" title="Hexo 常用命令（一）"></a>Hexo 常用命令（一）</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>常用的 hexo简写命令</p><p><code>hexo new draft &quot;new draft&quot;</code> #创建草稿</p><p><code>hexo publish [layout] &lt;filename&gt;</code> #将草稿升级为文章</p><p><code>hexo n &quot;new_post&quot;</code>==<code>hexo new &quot;new_post&quot;</code> #直接创建文章</p><p><code>hexo p</code>==<code>hexo publish</code>  #发布文章，将草稿升级为文章</p><p><code>hexo g</code>==<code>hexo generate</code> #生成</p><p><code>hexo s</code>==<code>hexo server</code> #在本地服务器预览，可修改localhost端口<br><code>hexo d</code>==<code>hexo deploy</code> #部署到远端服务器</p><p><code>hexo clean</code> #清除本地文件</p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode解题思路</title>
      <link href="/2018/11/14/LeetCode%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
      <url>/2018/11/14/LeetCode%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>Leetcode解题思路</p><p>在日常刷LeetCode题时，对自己思路做一些记录<br>语言主要为Python</p><p>Github上也有我上传好的代码: <a href="https://github.com/OliverLPH/Python-program-journal/tree/LeetCode-update/LeetCode" target="_blank" rel="noopener">Github_Peihan’s LeetCode</a></p><a id="more"></a><h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="Leetcode-1-Title-Two-Sum-两数之和"><a href="#Leetcode-1-Title-Two-Sum-两数之和" class="headerlink" title="Leetcode #1 Title: Two Sum(两数之和)"></a>Leetcode #1 Title: Two Sum(两数之和)</h2><p><a href="https://leetcode-cn.com/problems/two-sum/description/" target="_blank" rel="noopener">#1题目描述</a></p><details><br>    <summary>代码</summary><br>    <p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            remain_num = target - num</span><br><span class="line">            <span class="keyword">if</span> remain_num <span class="keyword">in</span> nums:</span><br><span class="line">                x = nums.index(remain_num)</span><br><span class="line">                y = nums.index(num)</span><br><span class="line">                <span class="keyword">if</span> x != y:</span><br><span class="line">                    result = [x,y]</span><br><span class="line">                <span class="keyword">elif</span> x == y:</span><br><span class="line">                    nums[x] = <span class="keyword">None</span></span><br><span class="line">                    <span class="keyword">if</span> remain_num <span class="keyword">in</span> nums:</span><br><span class="line">                        y = nums.index(num)</span><br><span class="line">                        result = [x,y]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br><br></p><br></details><h2 id="Leetcode-2-Title-Add-Two-Numbers-两数相加"><a href="#Leetcode-2-Title-Add-Two-Numbers-两数相加" class="headerlink" title="Leetcode #2 Title: Add Two Numbers(两数相加)"></a>Leetcode #2 Title: Add Two Numbers(两数相加)</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">#2题目描述</a></p><details><br>    <summary>代码</summary><br>    <p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dummy = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">        carry = <span class="number">0</span> <span class="comment">#进位</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                carry += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                carry += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur.next = ListNode(carry%<span class="number">10</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">            carry //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><br><br></p><br></details><h2 id="Leetcode-3-Title-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串"><a href="#Leetcode-3-Title-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串" class="headerlink" title="Leetcode #3 Title: Longest Substring Without Repeating Characters(无重复字符的最长子串)"></a>Leetcode #3 Title: Longest Substring Without Repeating Characters(无重复字符的最长子串)</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">#3题目描述</a></p><details><br>    <summary>代码</summary><br>    <p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        seen_map = &#123;&#125;</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        len_last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            l = s[i]</span><br><span class="line">            <span class="keyword">if</span> l <span class="keyword">in</span> seen_map:</span><br><span class="line">                len_last = min(i - seen_map[l] - <span class="number">1</span>, len_last) + <span class="number">1</span></span><br><span class="line">                seen_map[l] = i </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                len_last += <span class="number">1</span></span><br><span class="line">                seen_map[l] = i</span><br><span class="line">            <span class="keyword">if</span> len_last &gt;= max_len:</span><br><span class="line">                max_len = len_last</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><br><br></p><br></details><h2 id="Leetcode-9-Title-Palindrome-Number-回文数"><a href="#Leetcode-9-Title-Palindrome-Number-回文数" class="headerlink" title="Leetcode #9 Title: Palindrome Number(回文数)"></a>Leetcode #9 Title: Palindrome Number(回文数)</h2><p><a href="https://leetcode-cn.com/problems/palindrome-number/description/" target="_blank" rel="noopener">#9题目描述</a></p><p>这道题可以用一句话解决问题。但是仍然把integer转换成了character。<br>    思路如下：<br>    比如输入是 x = 123456<br>    str(x)表示 ‘123456’<br>    str(x)[::-1]表示反向的str(x),就是顺序相反，所以输出为 ‘654321’<br>    因为回文数的特征，所以直接str(x)==str(x)[::-1]就说明是回文数了</p><details><br>    <summary>代码</summary><br>    <p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> str(x)==str(x)[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><br><br></p><br></details><h2 id="Leetcode-11-Title-Container-With-Most-Water-盛最多水的容器"><a href="#Leetcode-11-Title-Container-With-Most-Water-盛最多水的容器" class="headerlink" title="Leetcode #11 Title: Container With Most Water(盛最多水的容器)"></a>Leetcode #11 Title: Container With Most Water(盛最多水的容器)</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">#11题目描述</a></p><p>这道题目的难点在于时间复杂度，如果直接使用两个循环，那么很容易就超时了。<br>因此我们将思路拓展一下，能够构成最大面积的值是怎么得到的。</p><p>比如输入是[1,2,1,4,2,1]</p><p>那么此时点的位置则是{(1,1),(2,2),(3,1),(4,4),(5,2),(6,1)}</p><p>然后我们就开始从两边的数字可以构成的面积开始推算，然后每次向中间移动一格。此时我们判断构成“容器”的两端的高度，然后将更矮那一端的 垂线 向中间移动，直到两个垂线相邻。</p><details><br>    <summary>代码</summary><br>    <p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_area = <span class="number">0</span> <span class="comment">#initilize max area</span></span><br><span class="line">        i = <span class="number">0</span> </span><br><span class="line">        j = len(height) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            area = (j-i)*min(height[i], height[j])</span><br><span class="line">            max_area = max(max_area, area)</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt;= height[j]:</span><br><span class="line">                i += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><br><br></p><br></details><h2 id="Leetcode-200-Title-Number-of-Islands-岛屿的个数"><a href="#Leetcode-200-Title-Number-of-Islands-岛屿的个数" class="headerlink" title="Leetcode #200 Title: Number of Islands(岛屿的个数)"></a>Leetcode #200 Title: Number of Islands(岛屿的个数)</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">#200题目描述</a></p><p>这题的思路就是使用一个额外的感染函数。遍历数组的时候，当遇到1则将其周围的所有1感染为2，依次感染下去，直到没有1。</p><details><br>    <summary>代码</summary><br>    <p><br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">n = len(grid)</span><br><span class="line">m = len(grid[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">grid = self.helper(grid,i,j,n,m)</span><br><span class="line">count +=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,grid,i,j,n,m)</span>:</span></span><br><span class="line"><span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i &gt;=n <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j &gt;=m <span class="keyword">or</span> grid[i][j] != <span class="string">'1'</span>:</span><br><span class="line"><span class="keyword">return</span> grid</span><br><span class="line">grid[i][j] = <span class="string">'2'</span></span><br><span class="line">self.helper(grid,i,j+<span class="number">1</span>,n,m)</span><br><span class="line">self.helper(grid,i+<span class="number">1</span>,j,n,m)</span><br><span class="line">self.helper(grid,i<span class="number">-1</span>,j,n,m)</span><br><span class="line">self.helper(grid,i,j<span class="number">-1</span>,n,m)</span><br><span class="line"><span class="keyword">return</span> grid</span><br></pre></td></tr></table></figure><br><br><br></p><br></details>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见机器学习算法</title>
      <link href="/2018/07/08/%E5%B8%B8%E8%A7%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
      <url>/2018/07/08/%E5%B8%B8%E8%A7%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>常见机器学习算法和模型<br><a id="more"></a></p><p>一般来说我们使用机器学习，就是为了分类。那么对于数据类型的不同，我们就要采用不同的分类方法。</p><p>首先说得最多的就是监督学习了。</p><h1 id="监督学习-supervised-Learning"><a href="#监督学习-supervised-Learning" class="headerlink" title="监督学习(supervised Learning)"></a>监督学习(supervised Learning)</h1><p>对于监督学习，我们一般有两个数据集，一个是训练集，一个是数据集。训练集用来训练模型，测试集用来测试模型的准确度。</p><h2 id="感知器-Perceptron-和支持向量机-SVM"><a href="#感知器-Perceptron-和支持向量机-SVM" class="headerlink" title="感知器(Perceptron)和支持向量机(SVM)"></a>感知器(Perceptron)和支持向量机(SVM)</h2><p>感知器和支持向量机均是基于线性规划来的。</p><h3 id="感知器-Perceptron"><a href="#感知器-Perceptron" class="headerlink" title="感知器(Perceptron)"></a>感知器(Perceptron)</h3><p>感知器的学习是错误驱使的。<br>我们使用感知器的过程中，因为普遍是二分类问题，而且是凸优化，那么我们就通过错分的sample，来不断学习到新的gradient，直到完全正确的分类。当然，我们也可以提前结束学习的过程，因为也有可能遇到outlier，然后严重影响我们的分类</p><h3 id="支持向量机-Support-vector-machine"><a href="#支持向量机-Support-vector-machine" class="headerlink" title="支持向量机(Support vector machine)"></a>支持向量机(Support vector machine)</h3><ol><li><p>它是针对线性可分情况进行分析，对于线性不可分的情况，通过使用非线性映射算法将低维输入空间线性不可分的样本转化为高维特征空间使其线性可分，从而使得高维特征空间采用线性算法对样本的非线性特征进行线性分析成为可能。</p></li><li><p>它基于结构风险最小化理论之上在特征空间中构建最优超平面，使得学习器得到全局最优化，并且在整个样本空间的期望以某个概率满足一定上界。</p></li></ol><h4 id="HARD-MARGIN-AND-SOFT-MARGIN-支持向量机"><a href="#HARD-MARGIN-AND-SOFT-MARGIN-支持向量机" class="headerlink" title="HARD MARGIN AND SOFT MARGIN 支持向量机"></a>HARD MARGIN AND SOFT MARGIN 支持向量机</h4><h4 id="Non-linear-SVM"><a href="#Non-linear-SVM" class="headerlink" title="Non-linear SVM"></a>Non-linear SVM</h4><h3 id="支持向量机-Python实现与调参"><a href="#支持向量机-Python实现与调参" class="headerlink" title="支持向量机 Python实现与调参"></a>支持向量机 Python实现与调参</h3><p>SVM 怎样能得到好的结果 </p><ol><li>对数据做归一化（simple scaling） </li><li>应用 RBF(Radial Basis Function) kernel </li><li>用cross-validation和grid-search 得到最优的c和g </li><li>用得到的最优c和g训练训练数据 </li><li>测试</li></ol><h4 id="SVM的优缺点"><a href="#SVM的优缺点" class="headerlink" title="SVM的优缺点"></a>SVM的优缺点</h4><p>优点</p><ol><li>解决小样本下机器学习问题。</li><li>解决非线性问题。</li><li>无局部极小值问题。（相对于神经网络等算法）</li><li>可以很好的处理高维数据集。</li><li>泛化能力比较强。</li></ol><p>缺点</p><ol><li>对于核函数的高维映射解释力不强，尤其是径向基函数。</li><li>对缺失数据敏感。</li></ol><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h4 id="决策树的优缺点及改进措施"><a href="#决策树的优缺点及改进措施" class="headerlink" title="决策树的优缺点及改进措施"></a>决策树的优缺点及改进措施</h4><p>优点</p><ol><li>决策树易于理解和解释，可以可视化分析，容易提取出规则。</li><li>可以同时处理标称型和数值型数据。</li><li>测试数据集时，运行速度比较快。</li><li>决策树可以很好的扩展到大型数据库中，同时它的大小独立于数据库大小。</li></ol><p>缺点</p><ol><li>对缺失数据处理比较困难。</li><li>容易出现过拟合问题。</li><li>忽略数据集中属性的相互关联。</li><li>ID3算法计算信息增益时结果偏向数值比较多的特征。</li></ol><p>改进措施</p><ol><li>对决策树进行剪枝。可以采用交叉验证法和加入正则化的方法。</li><li>使用基于决策树的combination算法，如bagging算法，随即森林(randomforest)算法，可以解决过拟合的问题</li></ol><h2 id="逻辑斯特回归-logistic-regression"><a href="#逻辑斯特回归-logistic-regression" class="headerlink" title="逻辑斯特回归(logistic regression)"></a>逻辑斯特回归(logistic regression)</h2><p>逻辑斯特回归是机器学习中的常见算法，这里我自己总结一下我在学习的过程中总结的知识点。</p><h3 id="逻辑回归的定义"><a href="#逻辑回归的定义" class="headerlink" title="逻辑回归的定义"></a>逻辑回归的定义</h3><p>逻辑回归假设数据服从伯努利分布,通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。</p><h4 id="逻辑回归的基本假设"><a href="#逻辑回归的基本假设" class="headerlink" title="逻辑回归的基本假设"></a>逻辑回归的基本假设</h4><p>伯努利分布</p><p>$$h_\theta(x;\theta)=p$$</p><p>$$p=\frac{1}{1+e^{-\theta^Tx}}$$</p><p>$$h_\theta(x;\theta)=\frac{1}{1+e^{-\theta^Tx}}$$</p><p>逻辑回归的损失函数</p><p>$$L_\theta(x)=\prod^m_{i=1}h_\theta(x^i;\theta)^{yi} \cdot (1-h_\theta(x^i;\theta))^{1-y^i}$$</p><p>求解逻辑回归</p><p>逻辑回归的分类</p><p>scikit-learn库中逻辑回归的使用</p><h4 id="逻辑斯特回归的优缺点"><a href="#逻辑斯特回归的优缺点" class="headerlink" title="逻辑斯特回归的优缺点"></a>逻辑斯特回归的优缺点</h4><p>优点</p><ol><li>计算代价不高，易于理解和实现</li></ol><p>缺点</p><ol><li>容易产生欠拟合。</li><li>分类精度不高。</li></ol><h2 id="朴素贝叶斯-Naive-Bayes"><a href="#朴素贝叶斯-Naive-Bayes" class="headerlink" title="朴素贝叶斯(Naive Bayes)"></a>朴素贝叶斯(Naive Bayes)</h2><h4 id="朴素贝叶斯的优缺点"><a href="#朴素贝叶斯的优缺点" class="headerlink" title="朴素贝叶斯的优缺点"></a>朴素贝叶斯的优缺点</h4><p>优点</p><ol><li>对大数量训练和查询时具有较高的速度。即使使用超大规模的训练集，针对每个项目通常也只会有相对较少的特征数，并且对项目的训练和分类也仅仅是特征概率的数学运算而已。</li><li>支持增量式运算。即可以实时的对新增的样本进行训练。</li><li>朴素贝叶斯对结果解释容易理解。</li></ol><p>缺点</p><ol><li>由于使用了样本属性独立性的假设，所以如果样本属性有关联时其效果不好。</li></ol><h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><h4 id="KNN的优缺点"><a href="#KNN的优缺点" class="headerlink" title="KNN的优缺点"></a>KNN的优缺点</h4><p>优点</p><ol><li>KNN是一种在线技术，新数据可以直接加入数据集而不必进行重新训练</li><li>KNN理论简单，容易实现</li></ol><p>缺点</p><ol><li>对于样本容量大的数据集计算量比较大。</li><li>样本不平衡时，预测偏差比较大。如：某一类的样本比较少，而其它类样本比较多。</li><li>KNN每一次分类都会重新进行一次全局运算。</li><li>k值大小的选择。</li></ol><h1 id="无监督学习-Unsupervised-Learning"><a href="#无监督学习-Unsupervised-Learning" class="headerlink" title="无监督学习(Unsupervised Learning)"></a>无监督学习(Unsupervised Learning)</h1><p>现实生活中常常会有这样的问题：缺乏足够的先验知识，因此难以人工标注类别或进行人工类别标注的成本太高。很自然地，我们希望计算机能代我们完成这些工作，或至少提供一些帮助。根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题，称之为无监督学习。</p><h2 id="聚类-clustering"><a href="#聚类-clustering" class="headerlink" title="聚类(clustering)"></a>聚类(clustering)</h2><h1 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h1><h1 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h1><h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h1><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h2 id="卷积神经网络-Convolutional-nerual-network-CNN"><a href="#卷积神经网络-Convolutional-nerual-network-CNN" class="headerlink" title="卷积神经网络(Convolutional nerual network) CNN"></a>卷积神经网络(Convolutional nerual network) CNN</h2><h2 id="循环神经网络-Recurrent-Neural-Network-RNN"><a href="#循环神经网络-Recurrent-Neural-Network-RNN" class="headerlink" title="循环神经网络(Recurrent Neural Network) RNN"></a>循环神经网络(Recurrent Neural Network) RNN</h2><h3 id="长短期记忆网络-Long-Short-Term-Memory-LSTM"><a href="#长短期记忆网络-Long-Short-Term-Memory-LSTM" class="headerlink" title="长短期记忆网络(Long Short-Term Memory) LSTM"></a>长短期记忆网络(Long Short-Term Memory) LSTM</h3><h3 id="Gated-Recurrent-Unit-GRU"><a href="#Gated-Recurrent-Unit-GRU" class="headerlink" title="Gated Recurrent Unit(GRU)"></a>Gated Recurrent Unit(GRU)</h3><h3 id="双向RNN"><a href="#双向RNN" class="headerlink" title="双向RNN"></a>双向RNN</h3><h2 id="深度神经网络"><a href="#深度神经网络" class="headerlink" title="深度神经网络"></a>深度神经网络</h2><h1 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h1><p>特征工程在做机器学习的过程中是尤其重要的。因为在现在数据越来越多的情况下，使用正确的特征，是至关重要的。</p><p>然后sklearn中也已经包含了许多的方法可以直接调用。</p><h2 id="数据的预处理"><a href="#数据的预处理" class="headerlink" title="数据的预处理"></a>数据的预处理</h2><h4 id="1-对数据规格的统一，这里有个名词叫（不属于同一量纲）即特征的规格不一样，不能够放在一起比较。"><a href="#1-对数据规格的统一，这里有个名词叫（不属于同一量纲）即特征的规格不一样，不能够放在一起比较。" class="headerlink" title="1. 对数据规格的统一，这里有个名词叫（不属于同一量纲）即特征的规格不一样，不能够放在一起比较。"></a>1. 对数据规格的统一，这里有个名词叫（不属于同一量纲）即特征的规格不一样，不能够放在一起比较。</h4><pre><code>&gt; 方法：无量纲化&gt; 无量纲化使不同规格的数据转换到同一规格。常见的无量纲化方法有标准化和区间缩放法。&gt;&gt; 标准化的前提是特征值服从正态分布，标准化后，其转换成标准正态分布。&gt;&gt; 区间缩放法利用了边界值信息，将特征的取值区间缩放到某个特点的范围，例如[0, 1]等。</code></pre><h3 id="标准化的方法"><a href="#标准化的方法" class="headerlink" title="标准化的方法"></a>标准化的方法</h3><p>计算出数据集的均值$ \bar x$和标准差$S $</p><p>$$x^{‘}=\frac{x-\bar x}{S}$$</p><p>使用preproccessing库的StandardScaler类对数据进行标准化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler </span><br><span class="line"><span class="comment">#标准化，返回值为标准化后的数据    </span></span><br><span class="line">StandardScaler().fit_transform(iris.data)</span><br></pre></td></tr></table></figure><h3 id="区间缩放法的方法"><a href="#区间缩放法的方法" class="headerlink" title="区间缩放法的方法"></a>区间缩放法的方法</h3><p>区间缩放法的思路有多种，常见的一种为利用两个最值进行缩放，公式表达为：<br>$$x^{‘}=\frac{x-Min}{Max-Min}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler  </span><br><span class="line"><span class="comment">#区间缩放，返回值为缩放到[0, 1]区间的数据  </span></span><br><span class="line">MinMaxScaler().fit_transform(iris.data)</span><br></pre></td></tr></table></figure><h3 id="标准化与归一化的区别"><a href="#标准化与归一化的区别" class="headerlink" title="标准化与归一化的区别"></a>标准化与归一化的区别</h3><p>简单来说，标准化是依照特征矩阵的列处理数据，其通过求z-score的方法，将样本的特征值转换到同一量纲下。归一化是依照特征矩阵的行处理数据，其目的在于样本向量在点乘运算或其他核函数计算相似性时，拥有统一的标准，也就是说都转化为“单位向量”。规则为l2的归一化公式如下：</p><p>$$x^{‘}=\frac{x}{\sqrt{\sum_j^m {x[j]}^2}}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Normalizer  </span><br><span class="line"><span class="comment">#归一化，返回值为归一化后的数据  </span></span><br><span class="line">Normalizer().fit_transform(iris.data)</span><br></pre></td></tr></table></figure><h4 id="2-信息冗余：对于某些定量特征，其包含的有效信息为区间划分，例如学习成绩，假若只关心“及格”或不“及格”，那么需要将定量的考分，转换成“1”和“0”表示及格和未及格。二值化可以解决这一问题。"><a href="#2-信息冗余：对于某些定量特征，其包含的有效信息为区间划分，例如学习成绩，假若只关心“及格”或不“及格”，那么需要将定量的考分，转换成“1”和“0”表示及格和未及格。二值化可以解决这一问题。" class="headerlink" title="2. 信息冗余：对于某些定量特征，其包含的有效信息为区间划分，例如学习成绩，假若只关心“及格”或不“及格”，那么需要将定量的考分，转换成“1”和“0”表示及格和未及格。二值化可以解决这一问题。"></a>2. 信息冗余：对于某些定量特征，其包含的有效信息为区间划分，例如学习成绩，假若只关心“及格”或不“及格”，那么需要将定量的考分，转换成“1”和“0”表示及格和未及格。二值化可以解决这一问题。</h4><h3 id="对定量特征二值化"><a href="#对定量特征二值化" class="headerlink" title="对定量特征二值化"></a>对定量特征二值化</h3><p>定量特征二值化的核心在于设定一个阈值，大于阈值的赋值为1，小于等于阈值的赋值为0，公式表达如下：</p><p>$$ x^{‘}=\left {<br>\begin{aligned}<br>1,x  &gt; threshold \<br>0,x  \leq threshold<br>\end{aligned}\right.<br>$$</p><p>使用preproccessing库的Binarizer类对数据进行二值化的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer   </span><br><span class="line"><span class="comment">#二值化，阈值设置为3，返回值为二值化后的数据  </span></span><br><span class="line">Binarizer(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure><h4 id="3-定性特征不能直接使用：某些机器学习算法和模型只能接受定量特征的输入，那么需要将定性特征转换为定量特征。最简单的方式是为每一种定性值指定一个定量值，但是这种方式过于灵活，增加了调参的工作。通常使用哑编码的方式将定性特征转换为定量特征：假设有N种定性值，则将这一个特征扩展为N种特征，当原始特征值为第i种定性值时，第i个扩展特征赋值为1，其他扩展特征赋值为0。哑编码的方式相比直接指定的方式，不用增加调参的工作，对于线性模型来说，使用哑编码后的特征可达到非线性的效果。"><a href="#3-定性特征不能直接使用：某些机器学习算法和模型只能接受定量特征的输入，那么需要将定性特征转换为定量特征。最简单的方式是为每一种定性值指定一个定量值，但是这种方式过于灵活，增加了调参的工作。通常使用哑编码的方式将定性特征转换为定量特征：假设有N种定性值，则将这一个特征扩展为N种特征，当原始特征值为第i种定性值时，第i个扩展特征赋值为1，其他扩展特征赋值为0。哑编码的方式相比直接指定的方式，不用增加调参的工作，对于线性模型来说，使用哑编码后的特征可达到非线性的效果。" class="headerlink" title="3. 定性特征不能直接使用：某些机器学习算法和模型只能接受定量特征的输入，那么需要将定性特征转换为定量特征。最简单的方式是为每一种定性值指定一个定量值，但是这种方式过于灵活，增加了调参的工作。通常使用哑编码的方式将定性特征转换为定量特征：假设有N种定性值，则将这一个特征扩展为N种特征，当原始特征值为第i种定性值时，第i个扩展特征赋值为1，其他扩展特征赋值为0。哑编码的方式相比直接指定的方式，不用增加调参的工作，对于线性模型来说，使用哑编码后的特征可达到非线性的效果。"></a>3. 定性特征不能直接使用：某些机器学习算法和模型只能接受定量特征的输入，那么需要将定性特征转换为定量特征。最简单的方式是为每一种定性值指定一个定量值，但是这种方式过于灵活，增加了调参的工作。通常使用哑编码的方式将定性特征转换为定量特征：假设有N种定性值，则将这一个特征扩展为N种特征，当原始特征值为第i种定性值时，第i个扩展特征赋值为1，其他扩展特征赋值为0。哑编码的方式相比直接指定的方式，不用增加调参的工作，对于线性模型来说，使用哑编码后的特征可达到非线性的效果。</h4><h3 id="对定性特征哑编码-one-hot"><a href="#对定性特征哑编码-one-hot" class="headerlink" title="对定性特征哑编码(one-hot)"></a>对定性特征哑编码(one-hot)</h3><p>对平级分类类型的特征采用one-hot编码来进行分类，从而使分类效果不受等级的影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="comment">#OneHot编码</span></span><br><span class="line">enc = OneHotEncoder()</span><br><span class="line">enc.fit([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h4 id="4-存在缺失值：缺失值需要补充。"><a href="#4-存在缺失值：缺失值需要补充。" class="headerlink" title="4. 存在缺失值：缺失值需要补充。"></a>4. 存在缺失值：缺失值需要补充。</h4><h3 id="缺失值计算"><a href="#缺失值计算" class="headerlink" title="缺失值计算"></a>缺失值计算</h3><h4 id="5-信息利用率低：不同的机器学习算法和模型对数据中信息的利用是不同的，之前提到在线性模型中，使用对定性特征哑编码可以达到非线性的效果。类似地，对定量变量多项式化，或者进行其他的转换，都能达到非线性的效果。"><a href="#5-信息利用率低：不同的机器学习算法和模型对数据中信息的利用是不同的，之前提到在线性模型中，使用对定性特征哑编码可以达到非线性的效果。类似地，对定量变量多项式化，或者进行其他的转换，都能达到非线性的效果。" class="headerlink" title="5. 信息利用率低：不同的机器学习算法和模型对数据中信息的利用是不同的，之前提到在线性模型中，使用对定性特征哑编码可以达到非线性的效果。类似地，对定量变量多项式化，或者进行其他的转换，都能达到非线性的效果。"></a>5. 信息利用率低：不同的机器学习算法和模型对数据中信息的利用是不同的，之前提到在线性模型中，使用对定性特征哑编码可以达到非线性的效果。类似地，对定量变量多项式化，或者进行其他的转换，都能达到非线性的效果。</h4><h3 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h3><h3 id="功能和说明的总结"><a href="#功能和说明的总结" class="headerlink" title="功能和说明的总结"></a>功能和说明的总结</h3><table><thead><tr><th>类</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>StandardScaler</td><td>无量纲化</td><td>标准化，基于特征矩阵的列，将特征值转换至服从标准正态分布</td></tr><tr><td>MinMaxScaler</td><td>无量纲化</td><td>区间缩放，基于最大最小值，将特征值转换到[0, 1]区间上</td></tr><tr><td>Normalizer</td><td>归一化</td><td>基于特征矩阵的行，将样本向量转换为“单位向量”</td></tr><tr><td>Binarizer</td><td>二值化</td><td>基于给定阈值，将定量特征按阈值划分</td></tr><tr><td>OneHotEncoder</td><td>哑编码</td><td>将定性数据编码为定量数据</td></tr><tr><td>Imputer</td><td>缺失值计算</td><td>计算缺失值，缺失值可填充为均值等</td></tr><tr><td>PolynomialFeatures</td><td>多项式数据转换</td><td>多项式数据转换</td></tr><tr><td>FunctionTransformer</td><td>自定义单元数据转换</td><td>使用单变元的函数来转换数据</td></tr></tbody></table><h2 id="特征的选择"><a href="#特征的选择" class="headerlink" title="特征的选择"></a>特征的选择</h2><p>当数据预处理完成后，我们需要选择有意义的特征输入机器学习的算法和模型进行训练。通常来说，从两个方面考虑来选择特征：</p><p>1、特征是否发散：如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。</p><p>2、特征与目标的相关性：这点比较显见，与目标相关性高的特征，应当优选选择。除方差法外，本文介绍的其他方法均从相关性考虑。</p><p>根据特征选择的形式又可以将特征选择方法分为3种：</p><p>1、Filter：过滤法，按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</p><p>2、Wrapper：包装法，根据目标函数（通常是预测效果评分），每次选择若干特征，或者排除若干特征。</p><p>3、Embedded：嵌入法，先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。</p><p>我们使用sklearn中的feature_selection库来进行特征选择。</p><h3 id="Filter-筛选器"><a href="#Filter-筛选器" class="headerlink" title="Filter 筛选器"></a>Filter 筛选器</h3><h4 id="方差选择法"><a href="#方差选择法" class="headerlink" title="方差选择法"></a>方差选择法</h4><p>使用方差选择法，先要计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征。使用feature_selection库的VarianceThreshold类来选择特征的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold  </span><br><span class="line"><span class="comment">#方差选择法，返回值为特征选择后的数据  </span></span><br><span class="line"><span class="comment">#参数threshold为方差的阈值  </span></span><br><span class="line">VarianceThreshold(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure><h4 id="相关系数法"><a href="#相关系数法" class="headerlink" title="相关系数法"></a>相关系数法</h4><p>使用相关系数法，先要计算各个特征对目标值的相关系数以及相关系数的P值。用feature_selection库的SelectKBest类结合相关系数来选择特征的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest  </span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr  </span><br><span class="line"><span class="comment">#选择K个最好的特征，返回选择特征后的数据  </span></span><br><span class="line"><span class="comment">#第一个参数为计算评估特征是否好的函数，该函数输入特征矩阵和目标向量，输出二元组（评分，P值）的数组，数组第i项为第i个特征的评分和P值。在此定义为计算相关系数  </span></span><br><span class="line"><span class="comment">#参数k为选择的特征个数  </span></span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(map(<span class="keyword">lambda</span> x:pearsonr(x, Y), X.T)).T, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure><h4 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h4><p>卡方检验就是统计样本的实际观测值与理论推断值之间的偏离程度，实际观测值与理论推断值之间的偏离程度就决定卡方值的大小，卡方值越大，越不符合；卡方值越小，偏差越小，越趋于符合，若两个值完全相等时，卡方值就为0，表明理论值完全符合。</p><p>注意：卡方检验针对分类变量。</p><p>经典的卡方检验是检验定性自变量对定性因变量的相关性。假设自变量有N种取值，因变量有M种取值，考虑自变量等于i且因变量等于j的样本频数的观察值与期望的差距，构建统计量：</p><p>$$x^{2}=\sum \frac{({A-E})^2}{E}$$</p><p>这个统计量的含义简而言之就是自变量对因变量的相关性。用feature_selection库的SelectKBest类结合卡方检验来选择特征的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest  </span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2  </span><br><span class="line"><span class="comment">#选择K个最好的特征，返回选择特征后的数据  </span></span><br><span class="line">SelectKBest(chi2, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure><h4 id="互信息法"><a href="#互信息法" class="headerlink" title="互信息法"></a>互信息法</h4><p>经典的互信息也是评价定性自变量对定性因变量的相关性的，互信息计算公式如下：</p><p>$$ I(X;Y) = \sum_{x \in X} \sum_{y \in Y} p(x,y)log\frac{p(x,y)}{p(x)p(y)}$$</p><p>为了处理定量数据，最大信息系数法被提出，使用feature_selection库的SelectKBest类结合最大信息系数法来选择特征的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest  </span><br><span class="line"><span class="keyword">from</span> minepy <span class="keyword">import</span> MINE  </span><br><span class="line"><span class="comment">#由于MINE的设计不是函数式的，定义mic方法将其为函数式的，返回一个二元组，二元组的第2项设置成固定的P值0.5  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mic</span><span class="params">(x, y)</span>:</span>  </span><br><span class="line">    m = MINE()  </span><br><span class="line">    m.compute_score(x, y)  </span><br><span class="line">    <span class="keyword">return</span> (m.mic(), <span class="number">0.5</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#选择K个最好的特征，返回特征选择后的数据  </span></span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(map(<span class="keyword">lambda</span> x:mic(x, Y), X.T)).T, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure><h3 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a>wrapper</h3><h3 id="Embeded"><a href="#Embeded" class="headerlink" title="Embeded"></a>Embeded</h3><h2 id="数据降维"><a href="#数据降维" class="headerlink" title="数据降维"></a>数据降维</h2><h3 id="主成分分析-Principal-Component-Analysis-PCA"><a href="#主成分分析-Principal-Component-Analysis-PCA" class="headerlink" title="主成分分析 Principal Component Analysis(PCA)"></a>主成分分析 Principal Component Analysis(PCA)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA   </span><br><span class="line"><span class="comment">#主成分分析法，返回降维后的数据  </span></span><br><span class="line"><span class="comment">#参数n_components为主成分数目  </span></span><br><span class="line">PCA(n_components=<span class="number">2</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure><h3 id="奇异值分解-Singular-Value-Decomposition-SVD"><a href="#奇异值分解-Singular-Value-Decomposition-SVD" class="headerlink" title="奇异值分解 Singular Value Decomposition(SVD)"></a>奇异值分解 Singular Value Decomposition(SVD)</h3><h3 id="线性判别分析-Linear-Discriminant-Analysis-LDA"><a href="#线性判别分析-Linear-Discriminant-Analysis-LDA" class="headerlink" title="线性判别分析 Linear Discriminant Analysis(LDA)"></a>线性判别分析 Linear Discriminant Analysis(LDA)</h3><p>使用lda库的LDA类选择特征的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.lda <span class="keyword">import</span> LDA    </span><br><span class="line"><span class="comment">#线性判别分析法，返回降维后的数据  </span></span><br><span class="line"><span class="comment">#参数n_components为降维后的维数  </span></span><br><span class="line">LDA(n_components=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure><h2 id="特征工程在kaggle的应用"><a href="#特征工程在kaggle的应用" class="headerlink" title="特征工程在kaggle的应用"></a>特征工程在kaggle的应用</h2><h1 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h1>]]></content>
      
      <categories>
          
          <category> 机器学习和数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见数据挖掘算法</title>
      <link href="/2018/07/05/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95/"/>
      <url>/2018/07/05/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>常见数据挖掘算法</p><p>这篇文章主要总结了我在学习数据挖掘中的一些知识点<br><a id="more"></a></p><p>其中大类包含</p><h1 id="Association-rules"><a href="#Association-rules" class="headerlink" title="Association rules"></a>Association rules</h1><h2 id="Apriori-algorithm-先验算法"><a href="#Apriori-algorithm-先验算法" class="headerlink" title="Apriori algorithm 先验算法"></a>Apriori algorithm 先验算法</h2><p>Apriori算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。在这里，所有支持度大于最小支持度的项集称为频繁项集，简称频集。</p><h2 id="Park-Chen-Yu-algorithm"><a href="#Park-Chen-Yu-algorithm" class="headerlink" title="Park-Chen-Yu algorithm"></a>Park-Chen-Yu algorithm</h2><h2 id="Simple-algorithm"><a href="#Simple-algorithm" class="headerlink" title="Simple algorithm"></a>Simple algorithm</h2><p>Simple算法: 从总的Sample里面，随机的取出一部分。</p><p>因为对于总的sample，我们取出来的 random sample 始终会有一个 采样频率。我们现在先说 probability p。假如相对于总的篮子 $p=\frac{1}{100}$ 。$\frac{s}{100} $就变成了新的阙值(Threshold).</p><h2 id="SON-algorithm"><a href="#SON-algorithm" class="headerlink" title="SON algorithm"></a>SON algorithm</h2><p>SON算法就是相当于把总的sample分成很多小的chunk，而不是像simple算法一样采样。</p><p>SON算法:原理是把本来的bucket分散成很多个chunk，每个chunk包含一定的bucket。再对每一个chunk跑 关联算法（比如A-priori算法）。对于threshold，每一个chunk都有自己新的threshold= s/p</p><p>其思想有点类似于 map reduce。正是Map reduce，所以该算法可以用在大数据上。</p><h1 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h1><p>聚类是一种无监督学习的算法，最常见的聚类就是使用K-means。</p><h2 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h2><p>K-means算法的实质就将不同的sample映射到一个平面上，在这个平面上，不同的sample之间有距离数值上的区别，通过这个区别，就可以清楚的发现这些sample之间的关系。</p><p>在选择某种距离作为数据样本间的相似性度量上，有几种常见的距离度量。</p><ol><li>欧几里得距离</li><li>曼哈顿距离</li><li>闵可夫斯基距离</li><li>皮尔逊系数(Pearson Correlation Coefficient)</li></ol><h3 id="K-means的优缺点"><a href="#K-means的优缺点" class="headerlink" title="K-means的优缺点"></a>K-means的优缺点</h3><p>优点</p><ol><li>经典算法，解决聚类问题非常简单和快速。</li><li>对处理大数据集，该算法是相对可伸缩和高效率的。因为它的复杂度是0 (n k t ) , 其中, n 是所有对象的数目, k 是簇的数目, t 是迭代的次数。通常k &lt; &lt;n 且t &lt; &lt;n 。</li><li>当结果簇是密集的，而簇与簇之间区别明显时, 它的效果较好。</li></ol><p>缺点</p><ol><li>在簇的平均值被定义的情况下才能使用，这对于处理符号属性的数据不适用。<br>必须事先给出k（要生成的簇的数目）。</li><li>K-Means算法对初值敏感，对于不同的初始值，可能会导致不同结果。</li><li>它对于“躁声”和孤立点数据是敏感的，少量的该类数据能够对平均值产生极大的影响。</li></ol><p>一些改进方法</p><ol><li>多设置一些不同的初值，对比最后的运算结果）一直到结果趋于稳定结束，比较耗时和浪费资源</li><li>很多时候，事先并不知道给定的数据集应该分成多少个类别才最合适。这也是 K-means 算法的一个不足。有的算法是通过类的自动合并和分裂，得到较为合理的类型数目K.</li><li>用更高级的K-means算法，如下</li></ol><h2 id="K-prototype算法"><a href="#K-prototype算法" class="headerlink" title="K-prototype算法"></a>K-prototype算法</h2><h2 id="K-中心点算法"><a href="#K-中心点算法" class="headerlink" title="K-中心点算法"></a>K-中心点算法</h2><h2 id="K-means-1"><a href="#K-means-1" class="headerlink" title="K-means++"></a>K-means++</h2><h2 id="Hierarchical-clustering"><a href="#Hierarchical-clustering" class="headerlink" title="Hierarchical clustering"></a>Hierarchical clustering</h2><h3 id="Agglomerative"><a href="#Agglomerative" class="headerlink" title="Agglomerative"></a>Agglomerative</h3><h3 id="Divisive"><a href="#Divisive" class="headerlink" title="Divisive"></a>Divisive</h3><h1 id="Page-Rank"><a href="#Page-Rank" class="headerlink" title="Page Rank"></a>Page Rank</h1><h1 id="Decision-tree"><a href="#Decision-tree" class="headerlink" title="Decision tree"></a>Decision tree</h1><h1 id="Naive-Bayes"><a href="#Naive-Bayes" class="headerlink" title="Naive Bayes"></a>Naive Bayes</h1><h1 id="Map-Reduce的思想"><a href="#Map-Reduce的思想" class="headerlink" title="Map Reduce的思想"></a>Map Reduce的思想</h1>]]></content>
      
      <categories>
          
          <category> 机器学习和数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL语法整理</title>
      <link href="/2018/06/23/SQL%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2018/06/23/SQL%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>SQL<br><a id="more"></a><br>SQL的用途十分广泛，其实很多时候也挺复杂的，我的SQL水平并不太好，然后就在这里总结一下除开增，删，改，查等基本操作的常用的一些SQL写法。</p><p>其中也会穿插一些在Leetcode上面做的SQL的题目，和自己的思路。</p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="聚合函数-GROUP-BY"><a href="#聚合函数-GROUP-BY" class="headerlink" title="聚合函数 GROUP BY"></a>聚合函数 GROUP BY</h3><p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p><h4 id="SQL-GROUP-BY-语法"><a href="#SQL-GROUP-BY-语法" class="headerlink" title="SQL GROUP BY 语法"></a>SQL GROUP BY 语法</h4><details><br>    <summary>代码</summary><br>    <p><br><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name;</span><br></pre></td></tr></table></figure><br><br></p><br></details><p>实例演示</p><table><thead><tr><th>Student</th><th>Class</th><th>Age</th><th>Gender</th></tr></thead><tbody><tr><td>Oliver</td><td>A</td><td>19</td><td>M</td></tr><tr><td>Allie</td><td>A</td><td>18</td><td>F</td></tr><tr><td>Lee</td><td>B</td><td>20</td><td>M</td></tr><tr><td>Jerry</td><td>A</td><td>19</td><td>M</td></tr><tr><td>Frank</td><td>B</td><td>18</td><td>F</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Class</span>,<span class="keyword">AVG</span>(Age) <span class="keyword">as</span> Avg_age </span><br><span class="line"><span class="keyword">FROM</span> Classes <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">Class</span>;</span><br></pre></td></tr></table></figure><p>以班级为聚合目标来进行聚合，求出班级的平均年龄得到下表。</p><table><thead><tr><th>Class</th><th>Avg_age</th></tr></thead><tbody><tr><td>A</td><td>18.6667</td></tr><tr><td>B</td><td>19.0000</td></tr></tbody></table><h3 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h3><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。HAVING 子句可以让我们筛选分组后的各组数据。</p><h4 id="SQL-HAVING-语法"><a href="#SQL-HAVING-语法" class="headerlink" title="SQL HAVING 语法"></a>SQL HAVING 语法</h4><details><br>    <summary>代码</summary><br>    <p><br><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name</span><br><span class="line"><span class="keyword">HAVING</span> aggregate_function(column_name) <span class="keyword">operator</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><br><br></p><br></details><p>参考网址：<a href="http://www.runoob.com/sql/sql-having.html" target="_blank" rel="noopener">菜鸟教程SQL Having语法</a></p><p>实例演示</p><p>“Websites”表的数据</p><table><thead><tr><th>id</th><th>name</th><th>url</th><th>alexa</th><th>country</th></tr></thead><tbody><tr><td>1</td><td>Google</td><td><a href="https://www.google.cm/" target="_blank" rel="noopener">https://www.google.cm/</a></td><td>1</td><td>USA</td></tr><tr><td>2</td><td>淘宝</td><td><a href="https://www.taobao.com/" target="_blank" rel="noopener">https://www.taobao.com/</a></td><td>13</td><td>CN</td></tr><tr><td>3</td><td>菜鸟教程</td><td><a href="http://www.runoob.com/" target="_blank" rel="noopener">http://www.runoob.com/</a></td><td>4689</td><td>CN</td></tr><tr><td>4</td><td>微博</td><td><a href="http://weibo.com/" target="_blank" rel="noopener">http://weibo.com/</a></td><td>20</td><td>CN</td></tr><tr><td>5</td><td>Facebook</td><td><a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a></td><td>3</td><td>USA</td></tr><tr><td>7</td><td>stackoverflow</td><td><a href="http://stackoverflow.com/" target="_blank" rel="noopener">http://stackoverflow.com/</a></td><td>0</td><td>IND</td></tr></tbody></table><p>“access_log”网站访问记录表的数据</p><table><thead><tr><th>aid</th><th>site_id</th><th>count</th><th>date</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>45</td><td>2016-05-10</td></tr><tr><td>2</td><td>3</td><td>100</td><td>2016-05-13</td></tr><tr><td>3</td><td>1</td><td>230</td><td>2016-05-14</td></tr><tr><td>4</td><td>2</td><td>10</td><td>2016-05-14</td></tr><tr><td>5</td><td>5</td><td>205</td><td>2016-05-14</td></tr><tr><td>6</td><td>4</td><td>13</td><td>2016-05-15</td></tr><tr><td>7</td><td>3</td><td>220</td><td>2016-05-15</td></tr><tr><td>8</td><td>5</td><td>545</td><td>2016-05-16</td></tr><tr><td>9</td><td>3</td><td>201</td><td>2016-05-17</td></tr></tbody></table><p>现在我们想要查找总访问量大于 200 的网站。<br>我们使用下面的 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Websites.name, Websites.url, <span class="keyword">SUM</span>(access_log.count) <span class="keyword">AS</span> nums <span class="keyword">FROM</span> (access_log</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Websites</span><br><span class="line"><span class="keyword">ON</span> access_log.site_id=Websites.id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Websites.name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(access_log.count) &gt; <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>得出了访问量大于200的网站</p><table><thead><tr><th>name</th><th>url</th><th>nums</th></tr></thead><tbody><tr><td>Facebook</td><td><a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a></td><td>750</td></tr><tr><td>Google</td><td><a href="https://www.google.cm/" target="_blank" rel="noopener">https://www.google.cm/</a></td><td>275</td></tr><tr><td>菜鸟教程</td><td><a href="http://www.runoob.com/" target="_blank" rel="noopener">http://www.runoob.com/</a></td><td>521</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hadoop(3.0.3)安装和配置过程（Mac）</title>
      <link href="/2018/06/23/Hadoop%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/06/23/Hadoop%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>最近想研究一下分布式计算工具，于是瞄上了Hadoop，在网上找了很多教程，但还是遇到了一些问题，在这里就我记录一下遇到的问题。<br>版本是 Hadoop(3.0.3)</p><h1 id="Hadoop-3-0-3"><a href="#Hadoop-3-0-3" class="headerlink" title="Hadoop(3.0.3)"></a>Hadoop(3.0.3)</h1><a id="more"></a><h2 id="Java环境检查"><a href="#Java环境检查" class="headerlink" title="Java环境检查"></a>Java环境检查</h2><h3 id="Java版本号检查"><a href="#Java版本号检查" class="headerlink" title="Java版本号检查"></a>Java版本号检查</h3><p>在terminal里输入如下指令可以查看Java版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure></p><p>如果Java已经是安装好了的话，就会出现如下的信息，里面的版本号可能会不一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version &quot;1.8.0_161&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="Java安装"><a href="#Java安装" class="headerlink" title="Java安装"></a>Java安装</h3><p>如果你没有Java，在这网址里可以安装<br><a href="https://www.java.com/zh_CN/" target="_blank" rel="noopener">Java安装网址</a><br>JDK的安装就搜索一下就有</p><h3 id="Java的的系统环境变量"><a href="#Java的的系统环境变量" class="headerlink" title="Java的的系统环境变量"></a>Java的的系统环境变量</h3><p>Java的系统环境变量是如下指令查询的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/libexec/java_home</span><br></pre></td></tr></table></figure></p><p>查询成功会反馈类似的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home</span><br></pre></td></tr></table></figure></p><p>该路径一会配置环境变量会用得上</p><h2 id="Hadoop下载"><a href="#Hadoop下载" class="headerlink" title="Hadoop下载"></a>Hadoop下载</h2><p><a href="http://hadoop.apache.org/releases.html" target="_blank" rel="noopener">Hadoop下载链接</a><br>我是在这里下载的3.0.3版本号。和之前2.x的版本有些许不一样。然后我是下载的编译好的binary版本。<br><a href="http://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-3.0.3/hadoop-3.0.3.tar.gz" target="_blank" rel="noopener">Hadoop3.0.3下载链接</a><br>进来之后任意选择镜像下载就可以了。</p><p>然后把解压后的文件夹hadoop-3.0.3存放到一个路径，比如我就把该文件夹放在documents下面。路径如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/Oliver/Documents/hadoop-3.0.3</span><br></pre></td></tr></table></figure></p><h2 id="配置Mac-os环境"><a href="#配置Mac-os环境" class="headerlink" title="配置Mac os环境"></a>配置Mac os环境</h2><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>这里就是我遇到问题最奇怪的地方</p><p>按照别人讲的教程大概有如下三种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br></pre></td></tr></table></figure></p><p>然后查看是否登陆成功,登陆成功讯息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br><span class="line">MBP:hadoop-3.0.3 Oliver$ ssh localhost</span><br><span class="line">Last login: Sat Jun 23 10:42:58 2018</span><br></pre></td></tr></table></figure></p><p>如果这里不是直接输出如上讯息，那么看是否需要输入密码，就根据提示一步一步来。<br>如果还是不成功，那么看如下方法</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><blockquote><p>打开系统偏好设置</p><blockquote><p>–&gt; 共享<br>–&gt; 勾选远程登录<br>–&gt; 设置允许访问：所有用户</p></blockquote></blockquote><p>然后再次在terminal里输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br></pre></td></tr></table></figure></p><p>参考网址：<a href="https://www.jianshu.com/p/de7eb61c983a" target="_blank" rel="noopener">Mac 系统安装Hadoop 2.7.3</a><br>参考网址：<a href="http://zhongyaonan.com/hadoop-tutorial/setting-up-hadoop-2-6-on-mac-osx-yosemite.html" target="_blank" rel="noopener">Setting up Hadoop 2.6 on Mac OS X Yosemite</a></p><p>如果以上方法不成功</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>生成一个ssh key并储存和拷贝，方法比较笨</p><hr><ol><li><p>先输入如下指令，生成ssh key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure><p> 然后会提示将该key储存在哪里，这个路径就随意设置,比如我就储存在hadoop文件夹内</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/Oliver/Documents/hadoop-3.0.3/sshkey/id_rsa</span><br></pre></td></tr></table></figure><p> 其中id_rsa就是我们要的文件。</p></li></ol><hr><ol start="2"><li><p>键入如下指令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /Users/Oliver/Documents/hadoop-3.0.3/sshkey/id_rsa.pub .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p> 其中路径要和我们储存key的路径一致。这是为了拷贝新生成的public key</p></li></ol><hr><ol start="3"><li><p>最后我们再试着输入</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br></pre></td></tr></table></figure><p> 此时应该就可以成功了</p></li></ol><hr><p>参考网址：<a href="https://stackoverflow.com/questions/15211848/hadoop-start-dfs-sh-permission-denied" target="_blank" rel="noopener">Hadoop: start-dfs.sh permission denied</a></p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>此方法还未经过验证（未完成）</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><h4 id="总环境变量配置"><a href="#总环境变量配置" class="headerlink" title="总环境变量配置"></a>总环境变量配置</h4><p>打开terminal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch ~/.bash_profile</span><br><span class="line">$ vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>执行以上代码可以进入Vim编辑器，编辑环境变量。<br>添加如下代码<br>键入 i 可以开始编辑（详情可以搜索Vim的命令）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Hadoop</span><br><span class="line">export HADOOP_HOME=/Users/Oliver/Documents/hadoop-3.0.3(这个是Hadoop distribution的路径，根据自己设定的来调)</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br></pre></td></tr></table></figure></p><p>然后保存再退出，以下是部分Vim的指令，其余指令可以自行搜索一下</p><table><thead><tr><th>命令</th><th>简单说明</th></tr></thead><tbody><tr><td>:w</td><td>保存编辑后的文件内容，但不退出vim编辑器</td></tr><tr><td>:wq</td><td>保存文件内容后退出vim编辑器</td></tr><tr><td>:q</td><td>在未做任何编辑处理而准备退出vim时，可以使用此命令</td></tr></tbody></table><p>退出Vim界面之后，在terminal里输入如下命令使变量立即生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p>我们就成功的配置好了Hadoop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop version</span><br></pre></td></tr></table></figure></p><p>用该语句来确认Hadoop配置,此时可以查看</p><h4 id="Hadoop文件配置"><a href="#Hadoop文件配置" class="headerlink" title="Hadoop文件配置"></a>Hadoop文件配置</h4><p>打开如下路径里的文件进行更改, 将代码复制进去</p><ol><li><p>etc/hadoop/core-site.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>etc/hadoop/hdfs-site.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>etc/hadoop/mapred-site.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>etc/hadoop/yarn-site.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p> 参考网址：<a href="http://zhongyaonan.com/hadoop-tutorial/setting-up-hadoop-2-6-on-mac-osx-yosemite.html" target="_blank" rel="noopener">Setting up Hadoop 2.6 on Mac OS X Yosemite</a></p></li></ol><ol start="5"><li><p>/etc/hadoop/hadoop-env.sh handoop环境<br>添加这段代码就可以了，注意就是Java的系统环境变量的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p> 可以看到前面一开始提到的用如下指令查询</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/libexec/java_home</span><br></pre></td></tr></table></figure></li></ol><h3 id="执行-start-hdfs-and-yarn"><a href="#执行-start-hdfs-and-yarn" class="headerlink" title="执行 start hdfs and yarn"></a>执行 start hdfs and yarn</h3><ol><li><p>在terminal里进入hadoop distribution的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd 到hadoop的文件夹，比如下面路径就是我的Hadoop</span><br><span class="line">$ cd /users/Oliver/documents/hadoop-3.0.3/</span><br></pre></td></tr></table></figure></li><li><p>对Namenode执行格式化操作 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop namenode -format</span><br></pre></td></tr></table></figure></li><li><p>启动hadoop</p><p> 启动NameNode和DataNode</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p> 成功后出现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting namenodes on [localhost]</span><br><span class="line">Starting datanodes</span><br><span class="line">Starting secondary namenodes [xiaohuobandeMBP.local]</span><br></pre></td></tr></table></figure><p> 启动ResourceManager和NodeManager</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><p> 成功后出现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br></pre></td></tr></table></figure></li><li><p>检查hadoop是否启动成功</p><p> 在terminal里输入</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br></pre></td></tr></table></figure><p> 会显示</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18739 Jps</span><br><span class="line">18133 NameNode</span><br><span class="line">18375 SecondaryNameNode</span><br><span class="line">18568 ResourceManager</span><br><span class="line">18665 NodeManager</span><br></pre></td></tr></table></figure><p> 则表示启动成功。<br> 此时在浏览器中访问localhost:8088和localhost:9870(hadoop3.x版本)，可以看到Hadoop的界面<br> localhost:50070(Hadoop2.x版本)</p></li></ol><p><img src="https://raw.githubusercontent.com/OliverLPH/Pictures/master/Blog/Hadoop/hadoop界面1.png" alt="hadoop界面"><br><img src="https://raw.githubusercontent.com/OliverLPH/Pictures/master/Blog/Hadoop/hadoop界面2.png" alt="hadoop界面"></p><hr><p>到此为止，Hadoop就已经完成配置了，接下来就是使用Hadoop了</p>]]></content>
      
      <categories>
          
          <category> 机器学习和数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 分布式计算 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo deploy问题</title>
      <link href="/2018/06/22/hexo-deploy%E9%97%AE%E9%A2%98/"/>
      <url>/2018/06/22/hexo-deploy%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>Hexo deploy的问题<br><a id="more"></a><br>一开始deploy成功之后，再重新deploy的时候，会发现并没有推送本地的文件到GitHub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">INFO  Copying files from extend dirs...</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">To github.com:OliverLPH/OliverLPH.github.io</span><br><span class="line"> + a8ea0df...bc3e952 HEAD -&gt; master (forced update)</span><br><span class="line">Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;git@github.com:OliverLPH/OliverLPH.github.io&apos;.</span><br><span class="line">INFO  Deploy done: git</span><br><span class="line">xiaohuobandeMBP:source Oliver$ hexo clean</span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br></pre></td></tr></table></figure><p>然后如上面的代码所示，hexo显示nothing to commit, working tree clean。</p><p>在网上搜索后发现有的几种方案</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这样就可以清理掉public文件夹，然后重新deploy</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>移除.deploy文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .deploy</span><br><span class="line">hexo generater</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Hello World! </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 初次使用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World！</title>
      <link href="/2018/06/22/hello-world/"/>
      <url>/2018/06/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Hello World!<br><a id="more"></a><br>终于把个人博客弄好的，菜鸟真是不容易。<br>还是要感谢一下网上的各路大神，都是借鉴了大家的攻略才终于弄好的。</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p>Hexo主题来源: <a href="https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md" target="_blank" rel="noopener">Next主题</a><br>Hexo配置参考1: <a href="https://baoyuzhang.github.io/2017/05/12/【Hexo搭建独立博客全纪录】（三）使用Hexo搭建博客/" target="_blank" rel="noopener">Hexo搭建独立博客全纪录</a><br>Hexo配置参考2: <a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">Hexo官方文档</a><br>Hexo配置参考3: <a href="http://oyjt.github.io/2016/01/16/hexo博客更换主题/" target="_blank" rel="noopener">hexo博客更换主题</a></p>]]></content>
      
      <categories>
          
          <category> Hello World! </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初次使用 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
